/*
 * chapter_3.hpp
 *
 *  Created on: Sept. 24, 2017
 *      Author: Pyrad
 * Description: Header file of chapter 3 Binary Tree
 *   Intention: Solutions for problems in Chapter 3[Binary Tree] of Code Interview Guide
 */

#ifndef CHAPTER_3_HPP_
#define CHAPTER_3_HPP_

/*
#include <algorithm>
#include <assert.h>
#include <string>
#include <iostream>
*/

#if 1
// Boost libraries
#include <boost/foreach.hpp>
#include <boost/algorithm/string.hpp>
#include <boost/lexical_cast.hpp>
#include <boost/tuple/tuple.hpp>
#include <boost/tuple/tuple_io.hpp>
#include <boost/scoped_ptr.hpp>

#include <stdio.h>
#include <iostream>
#include <stack>
#include <sstream>
#include <vector>
#include <queue>
#include <deque>
#include <cstring>
#include <map>
#include <set>
#endif // 0

#include "common_utils.hpp"

namespace C3 {

namespace CU = common_utils;

// [TIME_STAMP] Start at 20:07, 2017/09/24

// --------------------------------------------------------------------------------------------------------------
// 3.1 Traverse Methods of Binary Tree
// (1) Pre-Order Traverse (Recursive)
// (2) In-Order Traverse (Recursive)
// (3) Post-Order Traverse (Recursive)
// (4) Pre-Order Traverse (Non Recursive)
// (5) In-Order Traverse (Non Recursive)
// (6) Post-Order Traverse (Non Recursive)

void pre_order_traverse_recursive(CU::node *head);

void in_order_traverse_recursive(CU::node *head);

void post_order_traverse_recursive(CU::node *head);

void pre_order_traverse_non_recursive(CU::node *head);

void in_order_traverse_non_recursive(CU::node *head);

void post_order_traverse_non_recursive(CU::node *head);

// --------------------------------------------------------------------------------------------------------------
// 3.2 Print The Boarder of A Binary Tree in Anti-Clockwise Order
// Use 2 methods
// (1) boarder nodes contain
//		<1> head
//		<2> leaf nodes
//		<3> left most node in a level
//		<4> right most node in a level
// (2) boarder nodes contain
//		<1> head
//		<2> leaf nodes
//		<3> nodes extended from tree's left boarder
//		<4> nodes extended from tree's right boarder


// Solution for 1st methods
int get_height(CU::node *head, int level);

int get_height(CU::node *head);

void get_left_right_most_nodes(CU::node *head, std::vector<std::pair<CU::node*, CU::node*> >& v, int lvl);

// Print leaft nodes, except boarder nodes
void print_leaf_nodes(CU::node *head, std::vector<std::pair<CU::node*, CU::node*> >& v, int lvl);

void print_binary_tree_boarder(CU::node *head);

// Solution for 2nd methods

void print_left_edge(CU::node* head, bool b);

void print_right_edge(CU::node* head, bool b);

void print_edges(CU::node* head);


// [TIME_STAMP] Stop at 21:55, 2017/09/24


// [TIME_STAMP] Start at 16:02, 2017/10/03

// --------------------------------------------------------------------------------------------------------------
// 3.3 Print a binary tree with perceptual method
// [SKIP]

// --------------------------------------------------------------------------------------------------------------
// 3.4 Serialization and deserialization of a binary tree
// (1) Method 1, use pre-order traverse to do serialization and deserialization
// (2) Method 2, use queue traverse to do serialization and deserialization

// Use pre-order to serialize the binary tree
void binary_tree_serialization_by_preorder_process(CU::node* head, std::string& str);

std::string binary_tree_serialization_by_preorder(CU::node* head);

// deserialization a string(generated by pre-order traverse) to create a binary tree
CU::node* deserialization_to_create_binary_tree_process(std::string& str);

// Method 2, use queue traverse to do serialization and deserialization
std::string binary_tree_serialization_by_queue(CU::node* head);


CU::node* generate_node_by_string(const std::string& str);

CU::node* binary_tree_deserialization_by_queue(const std::string& s);

// --------------------------------------------------------------------------------------------------------------
// 3.5 Morris Traverse

// Morris Traverse in Pre-Order
void morris_pre_order(CU::node* head);

// Morris Traverse in In-Order
void morris_in_order(CU::node* head);

// Morris Traverse in Post-Order
// A customized function to reverse a linked list(use tree node 'right' as 'next' pointer)
CU::node* reverse_right_boarder(CU::node* head);

// Visit right boarder of a tree node
void visit_right_boarder(CU::node* h);

void print_right_boarder(CU::node* h);

// Morris Traverse in Post-Order Implementation
void morris_post_order(CU::node* head);


// --------------------------------------------------------------------------------------------------------------
// 3.6 Maximum path in a binary tree of a specified value sum
// k is the given sum for the path to find
// Pre-order traverse to resolve
void max_certain_sum_path_in_binary_tree_process(CU::node* head, int level, int sum, const int k, std::map<int, int>& m, int& max_height);

int max_certain_sum_path_in_binary_tree(CU::node* head, const int k);

// --------------------------------------------------------------------------------------------------------------
// 3.7 Find the biggest BST(sub-tree) in a binary tree

// Meaning of tps
// Position - Meaning
// 0 - Number of BST nodes
// 1 - Min value of this sub tree(could be BST tree or not)
// 2 - Max value of this sub tree(could be BST tree or not)
CU::node* biggest_sub_bst_process(CU::node* head, boost::tuple<int, int, int>& tps);

// [TIME_STAMP] Stop at 21:47, 2017/10/03


// [TIME_STAMP] Start at 10:04, 2017/10/04
// --------------------------------------------------------------------------------------------------------------
// 3.8 Find the number of the largest BST topologies in a binary tree
// (1) Use recursive soluation, time complexity is O(N^2)
// (2) Use node 'topo number contribution' method

// Check if node 'n' belongs to a BST tree(head is node 'head')
bool is_bst_node(CU::node* head, CU::node* n);

// Recursive resolution
int max_topo_process(CU::node* head, CU::node* n);

int max_topo(CU::node* head);

int largest_bst_topo_size(CU::node* head);


// Second solution
// Use node 'topo number contribution' method
class contribution_record {
public:
	// ctor
	contribution_record() : left_cont(0), right_cont(0) {}
	contribution_record(int l, int r) : left_cont(l), right_cont(r) {}
	contribution_record(const contribution_record& c) : left_cont(c.left_cont), right_cont(c.right_cont) {}
	contribution_record& operator= (const contribution_record& c) {
		left_cont = c.left_cont;
		right_cont = c.right_cont;
		return *this;
	}
	// member
	int left_cont;
	int right_cont;
};

int modify_boarder(CU::node* n, int hvalue, std::map<CU::node*, contribution_record>& m, bool lor);

int largest_bst_topo_size_2nd_process(CU::node* head, std::map<CU::node*, contribution_record>& m);

int largest_bst_topo_size_2nd(CU::node* head);

// --------------------------------------------------------------------------------------------------------------
// 3.9 Print a tree by level method and zigzag method

// Traverse by level
void visit_tree_by_level(CU::node* head);

// Traverse by zigzag method
void visit_tree_by_zigzag(CU::node* head);

// --------------------------------------------------------------------------------------------------------------
// 3.10 Adjust 2 error nodes in a BST(Binary Search Tree)
//    Two methods to adjust error nodes after the 2 error nodes are found
//    (1) swap the node value directly(easy)
//    (2) swap the node pointers(difficult)

// forward declaration
void adjust_two_error_nodes_in_bst_process_1(CU::node* perr1, CU::node* perr2);
void adjust_two_error_nodes_in_bst_process_2(CU::node* perr1, CU::node* perr2);

// main function
void adjust_two_error_nodes_in_bst(CU::node* head);

void adjust_two_error_nodes_in_bst_process_1(CU::node* perr1, CU::node* perr2);

void find_error_node_parents(CU::node* head, CU::node* perr1, CU::node* perr2, boost::tuple<CU::node*, CU::node*>& tps);

CU::node* adjust_two_error_nodes_pointers(CU::node* head, CU::node* perr1, CU::node* perr2, const boost::tuple<CU::node*, CU::node*>& tps);

void adjust_two_error_nodes_in_bst_process_2(CU::node* head, CU::node* perr1, CU::node* perr2);


// --------------------------------------------------------------------------------------------------------------
// 3.11 If tree1 contains the whole topologies of tree2

bool tree_topo_contain_process(CU::node* t1, CU::node* t2);

bool tree_topo_contain(CU::node* t1, CU::node* t2);

// --------------------------------------------------------------------------------------------------------------
// 3.12 If tree1 has a sub-tree which is exactly the same topologies as the tree2
// Two methods
// (1) Recursive resolution
// (2) Serialization + KMP

// Method 1
bool tree_topo_compare(CU::node* t1, CU::node* t2);

bool tree_topo_exactly_contain(CU::node* t1, CU::node* t2);

// Method 2, Serialization + KMP
void get_next_array(const std::string& m, std::vector<int>& next_array);

bool kmp_compare(const std::string& s, const std::string& m);

bool tree_topo_exactly_contain_2(CU::node* t1, CU::node* t2);

// --------------------------------------------------------------------------------------------------------------
// 3.13 Is a balanced tree

void is_balanced_tree_process(CU::node* n, bool& balanced, int& height);

bool is_balanced_tree(CU::node* head);

// --------------------------------------------------------------------------------------------------------------
// 3.14 Rebuild a binary tree as per an array generated in post-order traversal of a tree
// Prerequisite: values are unique in the array
// Two steps
// (1) Decide if an array is(or is not) generated in post-order traversal of a tree
// (2) If it is, rebuild the binary tree

// Solution to (1) Decide if an array is(or is not) generated in post-order traversal of a tree
// Use two pointers(indexes) 'less' and 'more'
// 'less' means the last one which is less than the head of this sub-tree(actually is the last element in the array)
// 'more' means the first one which is greater than the head of this sub-tree(actually is the last element in the array)

bool is_bst_post_array_process(const std::vector<int>& ivec, int start, int end);

bool is_bst_post_array(const std::vector<int>& ivec);

// Solution to (2) If an array is the traversal result of a BST in post order, rebuild it
CU::node* rebuild_bst_from_post_array_process(const std::vector<int>& ivec, int start, int end);

CU::node* rebuild_bst_from_post_array(const std::vector<int>& ivec);

// --------------------------------------------------------------------------------------------------------------
// 3.15 Judge if a tree is BST; Judge if a tree is a full binary tree
//  Two problems here, which are
//  (1) Judge if a tree is BST
//  (2) Judge if a tree is a full binary tree

// Solution to (1) Judge if a tree is BST
bool is_bst_tree(CU::node* head);

//  Solution to (2) Judge if a tree is a full binary tree
bool is_full_tree(CU::node* head);

// --------------------------------------------------------------------------------------------------------------
// 3.16 Generate a BST from a sorted/ordered array
// Prerequisites: values are unique in the array

CU::node* build_bst_from_sorted_array_process(const std::vector<int>& ivec, int start, int end);

CU::node* build_bst_from_sorted_array(const std::vector<int>& ivec);

// --------------------------------------------------------------------------------------------------------------
// 3.17 Find the successor of a tree node, this tree node has a pointer to its parent

// Given condition
class special_tree_node {
public:
	special_tree_node(int v) : parent(NULL), left(NULL), right(NULL) {}
public:
	special_tree_node* parent;
	special_tree_node* left;
	special_tree_node* right;
};

// Solution
special_tree_node* find_successor(special_tree_node* n);
// [TIME_STAMP] Stop at 22:00, 2017/10/04


// [TIME_STAMP] Start at 09:11, 2017/10/05
// --------------------------------------------------------------------------------------------------------------
// 3.18 Find the most recent common ancestor of 2 nodes in a tree
// Two problems
// (1) Query the most recent common ancestor of 2 nodes in a tree for just one time
// (2) Query the most recent common ancestor of 2 nodes in a tree for many times

// Solution to (1) Query the most recent common ancestor of 2 nodes in a tree for just one time
CU::node* most_recent_common_ancestor_process(CU::node* h, CU::node* n1, CU::node* n2, CU::node*& res);

CU::node* most_recent_common_ancestor(CU::node* h, CU::node* n1, CU::node* n2);

// Solution to (2) Query the most recent common ancestor of 2 nodes in a tree for many times

class most_recent_common_ancestor {
public:
	most_recent_common_ancestor() : m_head(NULL) {}
	most_recent_common_ancestor(CU::node* h) : m_head(h) { prepare(); }
	~most_recent_common_ancestor() { m_map.clear(); }
	void prepare();
	void build_parent_map(CU::node* h);
	CU::node* execute_query(CU::node* n1, CU::node* n2);
private:
	std::map<CU::node*, CU::node*> m_map;
	CU::node* m_head;
};

// void most_recent_common_ancestor::build_parent_map(CU::node* h);
// 
// void most_recent_common_ancestor::prepare();
// 
// CU::node* most_recent_common_ancestor::execute_query(CU::node* n1, CU::node* n2);

CU::node* most_recent_common_ancestor_query(CU::node* head, CU::node* n1, CU::node* n2);

// --------------------------------------------------------------------------------------------------------------
// 3.19 Tarjan Algorithm and disjoint set
// prerequisites:
// (1) Given a node pair array(query array, std::vector<std::pair<CU::node*, CU::node*> >)
//     Return the most recent common ancestors in the tree as array as per each pair in the array
// (2) Use Tarjan algorithm
// (3) Use disjoint set
// (4) Return result array(std::vector<CU::node*>), each element represents a parent of 2 node
// (5) Time complexity is O(N+M), N is tree total nodes, M is the size of query array

class disjoint_set {
public:
	disjoint_set() : m_head(NULL), m_father_map(NULL), m_rank_map(NULL) {
		m_father_map = new std::map<CU::node*, CU::node*>;
		m_rank_map = new std::map<CU::node*, int>;
		make_set();
	}
	disjoint_set(CU::node* head) : m_head(head), m_father_map(NULL), m_rank_map(NULL) {
		m_father_map = new std::map<CU::node*, CU::node*>;
		m_rank_map = new std::map<CU::node*, int>;
		make_set();
	}
	~disjoint_set() {
		if(m_father_map) {
			delete m_father_map;
		}
		if(m_rank_map) {
			delete m_rank_map;
		}
	}
	void make_set() {
		m_father_map->clear();
		m_rank_map->clear();
		pre_order_make_sets(m_head);
	}
	void pre_order_make_sets(CU::node* h) {
		if(!h) {
			return ;
		}
		m_father_map->insert(std::pair<CU::node*, CU::node*>(h, h));
		m_rank_map->insert(std::pair<CU::node*, int>(h, 0));
		pre_order_make_sets(h->left);
		pre_order_make_sets(h->right);
	}

	// Key implementation
public:
	// Path compress algorithm to find father
	CU::node* find_father(CU::node* n) {
		std::map<CU::node*, CU::node*>::iterator fitr = m_father_map->find(n);
		assert(fitr != m_father_map->end());
		CU::node* f = fitr->second;
		assert(f != NULL);
		if(f != n) {
			f = find_father(f);
		}
		// m_father_map[n] = f;
		m_father_map->insert(std::pair<CU::node*, CU::node*>(n, f));
		return f;
	}

	void union_nodes(CU::node* n1, CU::node* n2) {
		if(!n1 || !n2) {
			return ;
		}

		CU::node* f1 = find_father(n1);
		CU::node* f2 = find_father(n2);
		if(f1 != f2) {
			std::map<CU::node*, int>::iterator itr1 = m_rank_map->find(f1);
			assert(itr1 != m_rank_map->end());
			int rank1 = itr1->second;

			std::map<CU::node*, int>::iterator itr2 = m_rank_map->find(f2);
			assert(itr2 != m_rank_map->end());
			int rank2 = itr2->second;

			if(rank1 < rank2) {
				// m_father_map[f1] = f2;
				m_father_map->insert(std::pair<CU::node*, CU::node*>(f1, f2));
			} else if(rank1 > rank2) {
				// m_father_map[f2] = f1;
				m_father_map->insert(std::pair<CU::node*, CU::node*>(f2, f1));
			} else {
				// m_father_map[f2] = f1;
				m_father_map->insert(std::pair<CU::node*, CU::node*>(f2, f1));
				std::map<CU::node*, int>::iterator itr = m_rank_map->find(f1);
				assert(itr != m_rank_map->end());
				itr->second++;
			}
		}
	}

private:
	CU::node* m_head; // A tree head
	std::map<CU::node*, CU::node*> *m_father_map;
	std::map<CU::node*, int> *m_rank_map;
}; // class disjoint_set

class tarjan_solve {
public:
	tarjan_solve() : m_disjoint_set(NULL) {	}

	~tarjan_solve() {
		if(m_disjoint_set) {
			delete m_disjoint_set;
		}
	}

	void set_query_tasks(const std::list<std::pair<CU::node*, CU::node*> >& query, std::vector<CU::node*>& res) {
		if(query.empty()) {
			return ;
		}

		m_query_result_map.clear();
		m_query_task_map.clear();

		std::size_t i = 0;
		typedef std::pair<CU::node*, CU::node*> npair;
		BOOST_FOREACH(const npair& np, query) {
			CU::node* n1 = np.first;
			CU::node* n2 = np.second;
			if(n1 == n2 || !n1 || !n2) {
				res[i] = n1 ? n1 : n2;
			}
			std::map<CU::node*, std::list<CU::node*> >::iterator titr1 = m_query_task_map.find(n1);
			if(titr1 == m_query_task_map.end()) {
				std::list<CU::node*> nl;
				nl.push_back(n2);
				m_query_task_map.insert(std::pair<CU::node*, std::list<CU::node*> >(n1, nl));

				std::list<int> il;
				il.push_back(i);
				m_query_result_map.insert(std::pair<CU::node*, std::list<int> >(n1, il));
			} else {
				titr1->second.push_back(n2);
				std::map<CU::node*, std::list<int> >::iterator ritr = m_query_result_map.find(n1);
				assert(ritr != m_query_result_map.end());
				ritr->second.push_back(i);
			}

			std::map<CU::node*, std::list<CU::node*> >::iterator titr2 = m_query_task_map.find(n2);
			if(titr2 == m_query_task_map.end()) {
				std::list<CU::node*> nl;
				nl.push_back(n1);
				m_query_task_map.insert(std::pair<CU::node*, std::list<CU::node*> >(n2, nl));

				std::list<int> il;
				il.push_back(i);
				m_query_result_map.insert(std::pair<CU::node*, std::list<int> >(n2, il));
			} else {
				titr2->second.push_back(n1);
				std::map<CU::node*, std::list<int> >::iterator ritr = m_query_result_map.find(n2);
				assert(ritr != m_query_result_map.end());
				ritr->second.push_back(i);
			}

			i++;
		}
	}

	void set_results(CU::node* head, std::vector<CU::node*>& res) {
		if(!head) {
			return ;
		}

		set_results(head->left, res);
		m_disjoint_set->union_nodes(head->left, head);
		m_ancestor_map[m_disjoint_set->find_father(head)] = head;

		set_results(head->right, res);
		m_disjoint_set->union_nodes(head->right, head);
		m_ancestor_map[m_disjoint_set->find_father(head)] = head;

		std::map<CU::node*, std::list<CU::node*> >::iterator titr = m_query_task_map.find(head);
		assert(titr != m_query_task_map.end());
		std::list<CU::node*>& nlist = titr->second;

		std::map<CU::node*, std::list<int> >::iterator ritr = m_query_result_map.find(head);
		assert(ritr != m_query_result_map.end());
		std::list<int>& ilist = ritr->second;

		CU::node* n = NULL;
		CU::node* nfather = NULL;
		int index = 0;

		while(!nlist.empty()) {
			n = nlist.front();
			index = ilist.front();
			nlist.pop_front();
			ilist.pop_front();
			// find the set which n belongs to
			// That is to say find the representative node of a set which n belongs to
			nfather = m_disjoint_set->find_father(n);
			// Check nfather's ancestor
			std::map<CU::node*, CU::node*>::iterator itr = m_ancestor_map.find(nfather);
			if(itr != m_ancestor_map.end()) {
				res[index] = itr->second;
			}
		}
	}

	void execute_query(CU::node* head, const std::list<std::pair<CU::node*, CU::node*> >& query, std::vector<CU::node*>& res) {
		if(!head) {
			printf("Tree is empty\n");
			return ;
		}
		assert(query.size() == res.size());
		set_query_tasks(query, res);
		m_disjoint_set = new class disjoint_set(head);
		assert(m_disjoint_set);
		m_ancestor_map.clear();
		set_results(head, res);
		delete m_disjoint_set;
	}

private:
	// m_query_task_map should have the same size as m_query_result_map
	// m_query_task_map means node 'key' has query tasks with those 'value' nodes
	// m_query_result_map means the ancestors of node 'key' and those 'value' nodes should be placed where in the result array
	std::map<CU::node*, std::list<CU::node*> > m_query_task_map;
	std::map<CU::node*, std::list<int> > m_query_result_map;
	std::map<CU::node*, CU::node*> m_ancestor_map;
	// A disjoint set
	class disjoint_set *m_disjoint_set;
}; // class tarjan_solve


// --------------------------------------------------------------------------------------------------------------
// 3.20 Maximum path length between 2 nodes in a binary tree

int get_tree_height(CU::node* h);

int max_path_length_between_two_nodes_process(CU::node* h, int& max_height);

int max_path_length_between_two_nodes(CU::node* head);
// [TIME_STAMP] Stop at 13:42, 2017/10/05



// [TIME_STAMP] Start at 16:45, 2017/10/05
// --------------------------------------------------------------------------------------------------------------
// 3.21 Rebuild a binary tree from arrays of different traversal order
// Three problems
// (1) Rebuild a binary tree from arrays of PRE-order and IN-order
// (2) Rebuild a binary tree from arrays of IN-order and POST-order
// (3) Rebuild a binary tree from arrays of PRE-order and POST-order

// Solution to (1) Rebuild a binary tree from arrays of PRE-order and IN-order
CU::node* rebuild_from_pre_and_in_order_process(const std::vector<int>& pre, const std::vector<int>& in,
										int pre_start, int pre_end, int in_start, int in_end);

CU::node* rebuild_from_pre_and_in_order(const std::vector<int>& pre, const std::vector<int>& in);

// Solution to (2) Rebuild a binary tree from arrays of IN-order and POST-order
CU::node* rebuild_from_in_and_post_order_process(const std::vector<int>& in, const std::vector<int>& post,
										int in_start, int in_end, int post_start, int post_end);

CU::node* rebuild_from_in_and_post_order(const std::vector<int>& in, const std::vector<int>& post);

// Solution to (3) Rebuild a binary tree from arrays of PRE-order and POST-order
// Caution
//   every node in the tree satisfies the condition below would be recovered from PRE-order and POST-order arrays
// Condition
//   every node should have 2 children, except those leaf nodes

CU::node* rebuild_from_pre_and_post_order_process(const std::vector<int>& pre, const std::vector<int>& post,
										int pre_start, int pre_end, int post_start, int post_end);

CU::node* rebuild_from_pre_and_post_order(const std::vector<int>& pre, const std::vector<int>& post);

// --------------------------------------------------------------------------------------------------------------
// 3.22 Generate post-order traversal array directly from pre-order & in-order arrays

//  [In] pre, in
// [Out] post
void generate_post_order_from_pre_and_in_order(const std::vector<int>& pre, const std::vector<int>& in, std::vector<int>& post,
											int pre_start, int pre_end, int in_start, int in_end, int post_start, int post_end);

void generate_post_order_array_from_pre_and_in_order_arrays(const std::vector<int>& pre, const std::vector<int>& in);

// --------------------------------------------------------------------------------------------------------------
// 3.23 How many possibility is as per given number N to form a binary tree
// Prerequisites
//	(1) N mean array {1, 2, 3, ... , N-1, N} (N>0)
//	(2) array is the traversal result of a tree in in-order
// Solve
//	(1) Get number of possibilities
//	(2) Get all tree head nodes of those possibilities


// Solution to (1) Get number of possibilities
int possible_trees_as_per_given_number_process(const int start, const int end);

int possible_trees_as_per_given_number(const int n);

// Solution to (2) Get all tree head nodes of those possibilities
std::list<CU::node*> get_possible_tree_head_nodes_as_per_given_number_process(const int start, const int end);

// --------------------------------------------------------------------------------------------------------------
// 3.24 Calculate number of nodes in a complete binary tree
// Two methods
// (1) Traversal to count (normal solution)
// (2) Recursive to cout by check left-most nodes of right sub-tree

// Method 1
// [Skip]

// Method 2
int count_node_number(CU::node* n, const int height, const int level);

int node_number_in_complete_binary_tree(CU::node* head);

// [TIME_STAMP] Stop at 20:43, 2017/10/05


// [TIME_STAMP] Start at XX:XX, 2017/XX/XX
// [TIME_STAMP] Stop at XX:XX, 2017/XX/XX



// [TIME_STAMP] Start at XX:XX, 2017/XX/XX
// [TIME_STAMP] Stop at XX:XX, 2017/XX/XX

} // end-of-namespace C3




#endif /* CHAPTER_3_HPP_ */









